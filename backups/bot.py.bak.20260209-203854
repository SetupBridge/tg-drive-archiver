#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import asyncio
from datetime import datetime, timezone
from typing import Optional, Dict, Any, Tuple

from aiogram import Bot, Dispatcher, executor, types

from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google.auth.exceptions import RefreshError
from google_auth_oauthlib.flow import InstalledAppFlow

from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload


# =========================
# ENV / PATHS
# =========================
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
if not BOT_TOKEN:
    raise RuntimeError("âŒ BOT_TOKEN ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ù„Ù .env")

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, "data")
TOKENS_DIR = os.path.join(DATA_DIR, "tokens")
TMP_DIR = os.path.join(DATA_DIR, "tmp")
STORAGE_PATH = os.path.join(DATA_DIR, "storage.json")
CLIENT_SECRET_PATH = os.path.join(BASE_DIR, "client_secret.json")

os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(TOKENS_DIR, exist_ok=True)
os.makedirs(TMP_DIR, exist_ok=True)

# Google scopes (Drive + Sheets)
SCOPES = [
    "https://www.googleapis.com/auth/drive.file",
    "https://www.googleapis.com/auth/spreadsheets",
]

# Optional Google Sheet logging
SHEET_ID = os.getenv("SHEET_ID", "").strip()          # Ù„Ùˆ ØªØ¨ØºÙ‰ ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ø´ÙŠØª
SHEET_TAB = os.getenv("SHEET_TAB", "Sheet1").strip()  # Ø§Ø³Ù… Ø§Ù„ØªØ¨ÙˆÙŠØ¨

# Behavior
AUTO_DELETE_SECONDS = int(os.getenv("AUTO_DELETE_SECONDS", "3").strip() or "3")
ARCHIVE_CMD = "archive"  # /archive

# (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) ØªÙ‚ÙŠÙŠØ¯ setup Ø¹Ù„Ù‰ Ù…Ø§Ù„Ùƒ Ù…Ø­Ø¯Ø¯
OWNER_ID_ENV = os.getenv("OWNER_ID", "").strip()
OWNER_ID: Optional[int] = int(OWNER_ID_ENV) if OWNER_ID_ENV.isdigit() else None

# =========================
# BOT
# =========================
bot = Bot(token=BOT_TOKEN, parse_mode="HTML")
dp = Dispatcher(bot)

# In-memory pending setup flows: user_id -> dict(flow, msg_id_to_delete)
pending_setup: Dict[int, Dict[str, Any]] = {}


# =========================
# STORAGE HELPERS
# =========================
def load_storage() -> Dict[str, Any]:
    if not os.path.exists(STORAGE_PATH):
        return {}
    try:
        with open(STORAGE_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def save_storage(data: Dict[str, Any]) -> None:
    tmp = STORAGE_PATH + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    os.replace(tmp, STORAGE_PATH)

def get_owner_id() -> Optional[int]:
    if OWNER_ID is not None:
        return OWNER_ID
    st = load_storage()
    v = st.get("owner_id")
    return int(v) if isinstance(v, int) else None

def set_owner_id(user_id: int) -> None:
    st = load_storage()
    st["owner_id"] = int(user_id)
    save_storage(st)

def token_path_for_owner(owner_id: int) -> str:
    return os.path.join(TOKENS_DIR, f"google_{owner_id}.json")


# =========================
# AUTO DELETE
# =========================
async def auto_delete_message(chat_id: int, message_id: int, delay: int = AUTO_DELETE_SECONDS) -> None:
    await asyncio.sleep(delay)
    try:
        await bot.delete_message(chat_id, message_id)
    except Exception:
        pass

async def safe_delete(chat_id: int, message_id: int) -> None:
    try:
        await bot.delete_message(chat_id, message_id)
    except Exception:
        pass


# =========================
# GOOGLE AUTH
# =========================
def creds_from_file(path: str) -> Optional[Credentials]:
    if not os.path.exists(path):
        return None
    try:
        return Credentials.from_authorized_user_file(path, SCOPES)
    except Exception:
        return None

def save_creds(path: str, creds: Credentials) -> None:
    with open(path, "w", encoding="utf-8") as f:
        f.write(creds.to_json())

def get_drive_service(owner_id: int) -> Any:
    tok_path = token_path_for_owner(owner_id)
    creds = creds_from_file(tok_path)
    if not creds:
        raise RuntimeError("NOT_LINKED")

    if creds.expired and creds.refresh_token:
        try:
            creds.refresh(Request())
            save_creds(tok_path, creds)
        except RefreshError:
            raise RuntimeError("NEED_RELINK")

    return build("drive", "v3", credentials=creds)

def get_sheets_service(owner_id: int) -> Any:
    tok_path = token_path_for_owner(owner_id)
    creds = creds_from_file(tok_path)
    if not creds:
        raise RuntimeError("NOT_LINKED")

    if creds.expired and creds.refresh_token:
        try:
            creds.refresh(Request())
            save_creds(tok_path, creds)
        except RefreshError:
            raise RuntimeError("NEED_RELINK")

    return build("sheets", "v4", credentials=creds)


# =========================
# ARCHIVE HELPERS
# =========================
def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

async def download_file_to_tmp(message: types.Message) -> Tuple[str, str]:
    """
    Returns (local_path, original_name)
    """
    # priority: document > video > photo
    if message.document:
        file_id = message.document.file_id
        original_name = message.document.file_name or f"document_{message.message_id}"
        ext = os.path.splitext(original_name)[1] or ".bin"
    elif message.video:
        file_id = message.video.file_id
        original_name = f"video_{message.message_id}.mp4"
        ext = ".mp4"
    elif message.photo:
        file_id = message.photo[-1].file_id
        original_name = f"photo_{message.message_id}.jpg"
        ext = ".jpg"
    else:
        raise RuntimeError("UNSUPPORTED")

    file = await bot.get_file(file_id)
    local_path = os.path.join(TMP_DIR, f"{file.file_unique_id}{ext}")
    await bot.download_file(file.file_path, local_path)
    return local_path, original_name

def upload_to_drive(service: Any, local_path: str, drive_name: str, folder_id: Optional[str] = None) -> str:
    file_metadata: Dict[str, Any] = {"name": drive_name}
    if folder_id:
        file_metadata["parents"] = [folder_id]

    media = MediaFileUpload(local_path, resumable=True)
    created = service.files().create(
        body=file_metadata,
        media_body=media,
        fields="id"
    ).execute()
    return created["id"]

def append_to_sheet(service: Any, row: list) -> None:
    if not SHEET_ID:
        return
    range_name = f"{SHEET_TAB}!A1"
    body = {"values": [row]}
    service.spreadsheets().values().append(
        spreadsheetId=SHEET_ID,
        range=range_name,
        valueInputOption="USER_ENTERED",
        insertDataOption="INSERT_ROWS",
        body=body
    ).execute()


# =========================
# PERMISSIONS TEXT (Ù…Ø·Ù…Ù‘Ù†)
# =========================
PERMS_TEXT = (
    "ğŸ” <b>ØµÙ„Ø§Ø­ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¬Ø±ÙˆØ¨</b>\n\n"
    "Ø¹Ø´Ø§Ù† Ù†Ø®Ù„ÙŠ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù†Ø¸ÙŠÙØ© ÙˆÙ…Ø§ ØªØ²Ø¹Ù‘Ø¬ÙƒÙ…ØŒ Ø§Ù„Ø¨ÙˆØª ÙŠØ­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ©:\n"
    "â€¢ <b>Delete messages</b>\n\n"
    "âœ… <b>Ù„Ø§ ØªÙ‚Ù„Ù‚</b>: Ø§Ù„Ø¨ÙˆØª ÙŠØ­Ø°Ù ÙÙ‚Ø·:\n"
    "â€¢ Ø£Ù…Ø± <b>/archive</b> Ø§Ù„Ù„ÙŠ ØªÙƒØªØ¨Ù‡\n"
    "â€¢ ÙˆØ±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¨ÙˆØª (Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© / ØªÙ…Øª Ø§Ù„Ø£Ø±Ø´ÙØ©)\n\n"
    "ÙˆÙ„Ø§ ÙŠÙ„Ù…Ø³ Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©."
)


# =========================
# COMMANDS
# =========================
@dp.message_handler(commands=["start"])
async def cmd_start(message: types.Message):
    if message.chat.type in ("group", "supergroup"):
        # Suggest permissions if not admin/can_delete
        try:
            me = await bot.get_me()
            member = await bot.get_chat_member(message.chat.id, me.id)
            can_delete = getattr(member, "can_delete_messages", False)
            if not can_delete:
                await message.reply(PERMS_TEXT)
        except Exception:
            pass

        await message.reply(
            "Ù‡Ù„Ø§ ğŸ‘‹\n"
            "Ù„Ù„Ø£Ø±Ø´ÙØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¬Ø±ÙˆØ¨:\n"
            "1) Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©/Ø§Ù„ØµÙˆØ±Ø©\n"
            "2) Ø§ÙƒØªØ¨ <b>/archive</b>\n\n"
            "Ù„Ù„Ø±Ø¨Ø· Ù…Ø¹ Google: Ù†ÙÙ‘Ø° <b>/setup</b> ÙÙŠ Ø§Ù„Ø®Ø§Øµ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØª."
        )
        return

    # private
    await message.reply(
        "Ù‡Ù„Ø§ ğŸ‘‹\n\n"
        "â€¢ Ù„Ù„Ø±Ø¨Ø· Ù…Ø¹ Google: Ø§ÙƒØªØ¨ <b>/setup</b>\n"
        "â€¢ Ù„Ù„Ø£Ø±Ø´ÙØ© Ø¨Ø§Ù„Ø¬Ø±ÙˆØ¨: Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙˆØ§ÙƒØªØ¨ <b>/archive</b>\n\n"
        "Ù…Ù„Ø§Ø­Ø¸Ø©: /setup Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠ Ø§Ù„Ø®Ø§Øµ ÙÙ‚Ø·."
    )


@dp.message_handler(commands=["setup"])
async def cmd_setup(message: types.Message):
    if message.chat.type != "private":
        await message.reply("âš ï¸ Ø£Ù…Ø± <b>/setup</b> Ù„Ø§Ø²Ù… ÙÙŠ Ø§Ù„Ø®Ø§Øµ (Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¨ÙˆØª) ÙÙ‚Ø·.")
        return

    user_id = message.from_user.id

    # If OWNER_ID set, restrict
    if OWNER_ID is not None and user_id != OWNER_ID:
        await message.reply("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ù…Ù‚ÙŠÙ‘Ø¯. Ù…Ø§ ØªÙ‚Ø¯Ø± ØªØ³ÙˆÙŠ setup Ø¥Ù„Ø§ Ø§Ù„Ù…Ø§Ù„Ùƒ.")
        return

    # If no owner recorded, set first setup user as owner
    if get_owner_id() is None:
        set_owner_id(user_id)

    if not os.path.exists(CLIENT_SECRET_PATH):
        await message.reply("âŒ Ù…Ù„Ù <b>client_secret.json</b> ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù†ÙØ³ Ù…Ø¬Ù„Ø¯ bot.py")
        return

    # Start OAuth flow
    flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRET_PATH, SCOPES)

    # NOTE: OOB redirect (ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø´Ø±ÙˆØ¹Ùƒ â€” Ø¥Ø°Ø§ Ø´ØºØ§Ù„ Ù…Ø¹Ùƒ Ù‚Ø¨Ù„ ÙÙ‡Ùˆ ØªÙ…Ø§Ù…)
    flow.redirect_uri = "urn:ietf:wg:oauth:2.0:oob"

    auth_url, _ = flow.authorization_url(
        access_type="offline",
        include_granted_scopes="true",
        prompt="consent"
    )

    # Send instructions
    inst = (
        "ğŸ”— <b>Ø®Ø·ÙˆØ© Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Google</b>\n\n"
        "1) Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù‡Ø°Ø§:\n"
        f"{auth_url}\n\n"
        "2) ÙˆØ§ÙÙ‚ØŒ ÙˆØ¨ÙŠØ·Ù„Ø¹ Ù„Ùƒ <b>ÙƒÙˆØ¯</b>\n"
        "3) <b>Ø§Ù†Ø³Ø® Ø§Ù„ÙƒÙˆØ¯</b> ÙˆØ§Ù„ØµÙ‚Ù‡ Ù‡Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø© (Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø£ÙˆØ§Ù…Ø± / Ø¨Ø¯ÙˆÙ† /code)\n\n"
        "âœ… Ø¨Ø¹Ø¯ Ù…Ø§ ØªÙ„ØµÙ‚ Ø§Ù„ÙƒÙˆØ¯ Ø±Ø§Ø­ Ø£ÙƒÙ…Ù‘Ù„ Ø§Ù„Ø±Ø¨Ø· ÙˆØ£Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§."
    )
    sent = await message.reply(inst, disable_web_page_preview=True)

    pending_setup[user_id] = {"flow": flow, "inst_msg_id": sent.message_id}

    # optionally delete /setup command too
    asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))


@dp.message_handler(lambda m: m.chat.type == "private", content_types=types.ContentTypes.TEXT)
async def handle_private_text(message: types.Message):
    user_id = message.from_user.id

    # If waiting for oauth code
    if user_id in pending_setup:
        flow: InstalledAppFlow = pending_setup[user_id]["flow"]
        inst_msg_id: int = pending_setup[user_id]["inst_msg_id"]

        code = (message.text or "").strip()
        status = await message.reply("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Google...")

        try:
            flow.fetch_token(code=code)
            creds = flow.credentials

            owner_id = get_owner_id() or user_id
            tok_path = token_path_for_owner(owner_id)
            save_creds(tok_path, creds)

            await status.edit_text("âœ… ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­!")

            # Delete: user's code + instruction + status after delay
            asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))
            asyncio.create_task(auto_delete_message(message.chat.id, inst_msg_id, AUTO_DELETE_SECONDS))
            asyncio.create_task(auto_delete_message(message.chat.id, status.message_id, AUTO_DELETE_SECONDS))

            pending_setup.pop(user_id, None)
            return

        except Exception:
            await status.edit_text(
                "âŒ Ù…Ø§ Ø¶Ø¨Ø· Ø§Ù„Ø±Ø¨Ø·.\n\n"
                "â€¢ ØªØ£ÙƒØ¯ Ø¥Ù†Ùƒ Ù„ØµÙ‚Øª <b>Ø§Ù„ÙƒÙˆØ¯ ÙÙ‚Ø·</b>\n"
                "â€¢ ÙˆØ¬Ø±Ø¨ <b>/setup</b> Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©"
            )
            # Keep instructions; auto delete status
            asyncio.create_task(auto_delete_message(message.chat.id, status.message_id, AUTO_DELETE_SECONDS))
            return

    # otherwise ignore normal texts in private
    # (Ù†Ø®Ù„ÙŠÙ‡ Ù‡Ø§Ø¯ÙŠ)
    return


# =========================
# ARCHIVE COMMAND (Groups)
# =========================
@dp.message_handler(commands=[ARCHIVE_CMD], chat_type=["group", "supergroup"])
async def cmd_archive_group(message: types.Message):
    # Must be a reply
    if not message.reply_to_message:
        m = await message.reply("â„¹ï¸ Ø§Ø³ØªØ®Ø¯Ù…Ù‡Ø§ ÙƒØ°Ø§: Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©/Ø§Ù„ØµÙˆØ±Ø© Ø«Ù… Ø§ÙƒØªØ¨ <b>/archive</b>")
        asyncio.create_task(auto_delete_message(message.chat.id, m.message_id, AUTO_DELETE_SECONDS))
        asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))
        return

    owner_id = get_owner_id()
    if not owner_id:
        m = await message.reply("âš ï¸ Ù„Ø§Ø²Ù… ØªØ³ÙˆÙŠ <b>/setup</b> ÙÙŠ Ø§Ù„Ø®Ø§Øµ Ø£ÙˆÙ„Ø§Ù‹.")
        asyncio.create_task(auto_delete_message(message.chat.id, m.message_id, AUTO_DELETE_SECONDS))
        asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))
        return

    # Status message
    status = await message.reply("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...")

    # Try permissions check (optional)
    try:
        me = await bot.get_me()
        member = await bot.get_chat_member(message.chat.id, me.id)
        can_delete = getattr(member, "can_delete_messages", False)
        if not can_delete:
            warn = await message.reply(PERMS_TEXT)
            asyncio.create_task(auto_delete_message(message.chat.id, warn.message_id, 10))
    except Exception:
        pass

    try:
        drive = get_drive_service(owner_id)
        sheets = None
        if SHEET_ID:
            try:
                sheets = get_sheets_service(owner_id)
            except Exception:
                sheets = None

        target = message.reply_to_message

        # Text-only archive: save as txt to drive
        if target.text or target.caption:
            text = target.text or target.caption or ""
            fname = f"tg_text_{message.chat.id}_{target.message_id}.txt"
            local_path = os.path.join(TMP_DIR, fname)
            with open(local_path, "w", encoding="utf-8") as f:
                f.write(text)

            file_id = upload_to_drive(drive, local_path, fname, folder_id=None)

            if sheets:
                append_to_sheet(
                    sheets,
                    [
                        now_iso(),
                        str(message.chat.id),
                        str(target.message_id),
                        "text",
                        (message.from_user.username or ""),
                        (message.from_user.full_name or ""),
                        "OK",
                    ],
                )

            try:
                os.remove(local_path)
            except Exception:
                pass

        else:
            # Media archive
            local_path, original_name = await download_file_to_tmp(target)
            drive_name = f"{message.chat.id}_{target.message_id}_{original_name}"
            file_id = upload_to_drive(drive, local_path, drive_name, folder_id=None)

            if sheets:
                kind = "file"
                if target.photo:
                    kind = "photo"
                elif target.video:
                    kind = "video"
                elif target.document:
                    kind = "document"

                append_to_sheet(
                    sheets,
                    [
                        now_iso(),
                        str(message.chat.id),
                        str(target.message_id),
                        kind,
                        (message.from_user.username or ""),
                        (message.from_user.full_name or ""),
                        "OK",
                    ],
                )

            try:
                os.remove(local_path)
            except Exception:
                pass

        # âœ… Done (no Drive link)
        await status.edit_text("âœ… ØªÙ…Øª Ø§Ù„Ø£Ø±Ø´ÙØ©")

        # Auto delete messages (command + status) after 3s
        asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))
        asyncio.create_task(auto_delete_message(message.chat.id, status.message_id, AUTO_DELETE_SECONDS))

    except RuntimeError as e:
        if str(e) == "NOT_LINKED":
            await status.edit_text("âš ï¸ Ù„Ø§Ø²Ù… ØªØ³ÙˆÙŠ <b>/setup</b> ÙÙŠ Ø§Ù„Ø®Ø§Øµ Ø£ÙˆÙ„Ø§Ù‹.")
        elif str(e) == "NEED_RELINK":
            await status.edit_text("âš ï¸ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø±Ø¨Ø·. Ø³ÙˆÙ‘Ù <b>/setup</b> Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ© ÙÙŠ Ø§Ù„Ø®Ø§Øµ.")
        else:
            await status.edit_text("âŒ ØµØ§Ø± Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø£Ø±Ø´ÙØ©.")
        asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))
        asyncio.create_task(auto_delete_message(message.chat.id, status.message_id, AUTO_DELETE_SECONDS))

    except Exception:
        await status.edit_text("âŒ ØµØ§Ø± Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø£Ø±Ø´ÙØ©.")
        asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))
        asyncio.create_task(auto_delete_message(message.chat.id, status.message_id, AUTO_DELETE_SECONDS))


# =========================
# ARCHIVE COMMAND (Private) - optional guide
# =========================
@dp.message_handler(commands=[ARCHIVE_CMD], chat_type=["private"])
async def cmd_archive_private(message: types.Message):
    await message.reply(
        "â„¹ï¸ Ø§Ù„Ø£Ø±Ø´ÙØ© ØªÙ†ÙØ¹ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¬Ø±ÙˆØ¨Ø§Øª.\n"
        "ÙÙŠ Ø§Ù„Ø¬Ø±ÙˆØ¨: Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©/Ø§Ù„ØµÙˆØ±Ø© Ø«Ù… Ø§ÙƒØªØ¨ <b>/archive</b>."
    )
    asyncio.create_task(auto_delete_message(message.chat.id, message.message_id, AUTO_DELETE_SECONDS))


# =========================
# MAIN
# =========================
if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
