# -*- coding: utf-8 -*-
import os
import re
import json
import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Optional, Dict, Any, List

from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import (
    InlineKeyboardMarkup, InlineKeyboardButton,
    BotCommand, BotCommandScopeAllPrivateChats, BotCommandScopeAllGroupChats,
)
from aiogram.utils.exceptions import NetworkError, BotBlocked

from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google.auth.exceptions import RefreshError
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload


# =========================
# ENV loader (Ø¨Ø¯ÙˆÙ† dotenv)
# =========================
def _load_env_file(path: str = ".env") -> None:
    """
    Simple .env loader:
    KEY=value
    lines starting with # ignored
    """
    if not os.path.exists(path):
        return
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                k, v = line.split("=", 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                # Ù„Ø§ Ù†ØºØ·ÙŠ Ø§Ù„Ù…ØªØºÙŠØ± Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ø£ØµÙ„Ù‹Ø§ ÙÙŠ Ø§Ù„Ø¨ÙŠØ¦Ø©
                if k and (k not in os.environ or not os.environ.get(k)):
                    os.environ[k] = v
    except Exception:
        # Ø¥Ø°Ø§ ÙØ´Ù„ØŒ Ù†Ø®Ù„ÙŠ Ø§Ù„Ø¨ÙˆØª ÙŠÙƒÙ…Ù„ ÙˆÙŠØ¹Ø·ÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø¶Ø­Ø© Ù„Ø§Ø­Ù‚Ù‹Ø§
        pass


_load_env_file(".env")

BOT_TOKEN = (os.getenv("BOT_TOKEN") or "").strip()
DRIVE_PARENT_FOLDER_ID = (os.getenv("DRIVE_FOLDER_ID") or "").strip()  # Ø§Ø®ØªÙŠØ§Ø±ÙŠ

if not BOT_TOKEN:
    raise RuntimeError("âŒ BOT_TOKEN ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ Ù…Ø³ÙˆÙŠ Ù…Ù„Ù .env ÙˆÙÙŠÙ‡ BOT_TOKEN=...")

# Google scopes
SCOPES = [
    "https://www.googleapis.com/auth/drive.file",
]

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, "data")
STORAGE_DIR = os.path.join(BASE_DIR, "storage")
LOGS_DIR = os.path.join(BASE_DIR, "logs")
TMP_DIR = os.path.join(BASE_DIR, "out")

for d in (DATA_DIR, STORAGE_DIR, LOGS_DIR, TMP_DIR):
    os.makedirs(d, exist_ok=True)

STATE_FILE = os.path.join(DATA_DIR, "state.json")
GROUPS_FILE = os.path.join(DATA_DIR, "groups.json")


# =========================
# Logging
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    handlers=[
        logging.FileHandler(os.path.join(LOGS_DIR, "bot.log"), encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
log = logging.getLogger("tg-drive-archiver")


# =========================
# Storage helpers
# =========================
def _read_json(path: str, default: Any) -> Any:
    try:
        if not os.path.exists(path):
            return default
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return default


def _write_json(path: str, data: Any) -> None:
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)


def get_state() -> Dict[str, Any]:
    return _read_json(STATE_FILE, default={})


def set_state(state: Dict[str, Any]) -> None:
    _write_json(STATE_FILE, state)


def get_groups() -> Dict[str, Any]:
    return _read_json(GROUPS_FILE, default={})


def set_groups(groups: Dict[str, Any]) -> None:
    _write_json(GROUPS_FILE, groups)


# =========================
# Google Drive helpers
# =========================
def _creds_path(group_id: int) -> str:
    return os.path.join(STORAGE_DIR, f"creds_{group_id}.json")


def load_creds(group_id: int) -> Optional[Credentials]:
    path = _creds_path(group_id)
    if not os.path.exists(path):
        return None
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        return Credentials.from_authorized_user_info(data, SCOPES)
    except Exception:
        return None


def save_creds(group_id: int, creds: Credentials) -> None:
    path = _creds_path(group_id)
    data = {
        "token": creds.token,
        "refresh_token": creds.refresh_token,
        "token_uri": creds.token_uri,
        "client_id": creds.client_id,
        "client_secret": creds.client_secret,
        "scopes": creds.scopes,
    }
    _write_json(path, data)


def build_drive(creds: Credentials):
    return build("drive", "v3", credentials=creds, cache_discovery=False)


def ensure_valid_creds(group_id: int) -> Optional[Credentials]:
    creds = load_creds(group_id)
    if not creds:
        return None
    try:
        if creds.expired and creds.refresh_token:
            creds.refresh(Request())
            save_creds(group_id, creds)
        return creds
    except (RefreshError, Exception):
        return None


def create_folder_if_needed(drive, name: str, parent_id: Optional[str]) -> str:
    """
    Create folder in Drive, return folder id.
    """
    metadata = {
        "name": name,
        "mimeType": "application/vnd.google-apps.folder",
    }
    if parent_id:
        metadata["parents"] = [parent_id]

    folder = drive.files().create(body=metadata, fields="id").execute()
    return folder["id"]


def get_or_create_group_folder(group_id: int, group_title: str, drive) -> str:
    state = get_state()
    folders = state.get("group_folders", {})
    gid = str(group_id)

    if gid in folders and folders[gid]:
        return folders[gid]

    # create new folder
    safe_title = re.sub(r"[^\w\s\-\(\)\[\]]+", "", group_title).strip() or "TelegramGroup"
    folder_name = f"TG Archive - {safe_title} ({group_id})"
    folder_id = create_folder_if_needed(drive, folder_name, DRIVE_PARENT_FOLDER_ID or None)

    folders[gid] = folder_id
    state["group_folders"] = folders
    set_state(state)
    return folder_id


# =========================
# Bot & Dispatcher
# =========================
bot = Bot(token=BOT_TOKEN, parse_mode=types.ParseMode.HTML)
dp = Dispatcher(bot)

# In-memory pending setup: user_id -> group_id
pending_setup: Dict[int, int] = {}


# =========================
# UI Texts
# =========================
WELCOME_TEXT = (
    "ğŸ‘‹ <b>Ù‡Ù„Ø§ ÙÙŠÙƒ!</b>\n\n"
    "Ù‡Ø°Ø§ <b>Ø¨ÙˆØª Ø§Ù„Ø£Ø±Ø´ÙØ©</b> â€” ÙŠØ­ÙØ¸ Ø§Ù„Ù…Ù„ÙØ§Øª/Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ ÙˆÙŠØ±ÙØ¹Ù‡Ø§ Ø¥Ù„Ù‰ Google Drive.\n\n"
    "Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø£ÙˆÙ„Ù‰:\n"
    "1) <b>Ø£Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©</b>\n"
    "2) Ù…Ù† Ù‡Ù†Ø§ Ø§Ø¶ØºØ· <b>Ø¥Ø¹Ø¯Ø§Ø¯ Google Drive</b> ÙˆØ§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©\n\n"
    "Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ØŒ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:\n"
    "â€¢ <b>Ø±Ø¯</b> Ø¹Ù„Ù‰ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§ÙƒØªØ¨: <code>archive</code>\n"
)

INFO_TEXT = (
    "â„¹ï¸ <b>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø¨ÙˆØª</b>\n\n"
    "â€¢ ÙŠØ±ÙØ¹ Ù…Ù„ÙØ§Øª Telegram Ø¥Ù„Ù‰ Google Drive Ø¯Ø§Ø®Ù„ Ù…Ø¬Ù„Ø¯ Ø®Ø§Øµ Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©.\n"
    "â€¢ Ù…Ø§ ÙŠØ±Ø³Ù„ Ù„Ùƒ Ø±ÙˆØ§Ø¨Ø· Ø¥Ù„Ø§ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©.\n"
    "â€¢ Ø¥Ø°Ø§ ØªØ¨ÙŠ Ø§Ù„Ø¨ÙˆØª ÙŠØ­Ø°Ù Ø±Ø³Ø§Ø¦Ù„ Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø±Ø´ÙØ© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ØŒ Ù„Ø§Ø²Ù… ØªØ¹Ø·ÙŠÙ‡ ØµÙ„Ø§Ø­ÙŠØ© Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©.\n"
)

HELP_TEXT = (
    "ğŸ†˜ <b>Ù…Ø³Ø§Ø¹Ø¯Ø©</b>\n\n"
    "Ø¥Ø°Ø§ Ù…Ø§ Ø¶Ø¨Ø· Ø§Ù„Ø±Ø¨Ø·:\n"
    "â€¢ ØªØ£ÙƒØ¯ Ù…Ù„Ù <code>client_secret.json</code> Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù†ÙØ³ Ù…Ø¬Ù„Ø¯ <code>bot.py</code>\n"
    "â€¢ Ø£Ø¹Ø¯ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù† Ø²Ø±: <b>Ø¥Ø¹Ø¯Ø§Ø¯ Google Drive</b>\n\n"
    "Ø§Ù„Ø£Ø±Ø´ÙØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:\n"
    "â€¢ Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø«Ù… Ø§ÙƒØªØ¨: <code>archive</code>\n"
)

SETUP_INTRO = (
    "ğŸ”— <b>Ø¥Ø¹Ø¯Ø§Ø¯ Google Drive</b>\n\n"
    "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ù„ÙŠ ØªØ¨ÙŠ ØªØ±Ø¨Ø·Ù‡Ø§ Ø¨Ù€ Google Drive:"
)

SETUP_NEED_CLIENT_SECRET = (
    "âŒ Ù…Ø§ Ù„Ù‚ÙŠØª <code>client_secret.json</code> ÙÙŠ Ù†ÙØ³ Ù…Ø¬Ù„Ø¯ <code>bot.py</code>\n"
    "Ø­Ø·Ù‡ Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³Ø§Ø± Ø«Ù… Ø¬Ø±Ù‘Ø¨ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©."
)


def kb_private_home() -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=2)
    kb.add(
        InlineKeyboardButton("Google Drive (Setup) ğŸ”—", callback_data="setup"),
        InlineKeyboardButton("Ù…Ø¹Ù„ÙˆÙ…Ø§Øª â„¹ï¸", callback_data="info"),
    )
    kb.add(InlineKeyboardButton("Ù…Ø³Ø§Ø¹Ø¯Ø© ğŸ†˜", callback_data="help"))
    return kb


def kb_groups_list(groups: Dict[str, Any]) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=1)
    items = []
    for gid, meta in groups.items():
        title = meta.get("title") or gid
        items.append((int(gid), title))

    # sort by title
    items.sort(key=lambda x: x[1].lower())

    for gid, title in items[:30]:
        kb.add(InlineKeyboardButton(f"{title}", callback_data=f"pick_group:{gid}"))

    kb.add(InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ â†©ï¸", callback_data="home"))
    return kb


def kb_setup_actions(group_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=1)
    kb.add(InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ â†©ï¸", callback_data="setup"))
    kb.add(InlineKeyboardButton("Ù…Ø¹Ù„ÙˆÙ…Ø§Øª â„¹ï¸", callback_data="info"))
    return kb


# =========================
# Telegram commands scopes
# =========================
async def configure_commands():
    # Private: show only /start
    await bot.set_my_commands(
        commands=[BotCommand(command="start", description="Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª")],
        scope=BotCommandScopeAllPrivateChats(),
    )
    # Groups: hide commands (empty list)
    await bot.set_my_commands(
        commands=[],
        scope=BotCommandScopeAllGroupChats(),
    )


# =========================
# Utilities
# =========================
def is_private(message: types.Message) -> bool:
    return message.chat.type == types.ChatType.PRIVATE


def is_group(message: types.Message) -> bool:
    return message.chat.type in (types.ChatType.GROUP, types.ChatType.SUPERGROUP)


async def safe_send_private(user_id: int, text: str, reply_markup=None):
    try:
        await bot.send_message(user_id, text, reply_markup=reply_markup, disable_web_page_preview=True)
    except BotBlocked:
        pass
    except Exception:
        pass


def client_secret_path() -> str:
    return os.path.join(BASE_DIR, "client_secret.json")


def build_oauth_url() -> str:
    """
    Build OOB auth URL using InstalledAppFlow.
    """
    flow = InstalledAppFlow.from_client_secrets_file(client_secret_path(), SCOPES)
    # We need OOB for mobile copy/paste
    auth_url, _ = flow.authorization_url(
        access_type="offline",
        include_granted_scopes="true",
        prompt="consent",
    )
    return auth_url


def exchange_code_for_creds(code: str) -> Credentials:
    flow = InstalledAppFlow.from_client_secrets_file(client_secret_path(), SCOPES)
    flow.fetch_token(code=code.strip())
    return flow.credentials


async def download_telegram_file(file_id: str, dst_path: str) -> None:
    file = await bot.get_file(file_id)
    await bot.download_file(file.file_path, destination=dst_path)


def guess_filename_from_message(msg: types.Message) -> str:
    ts = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
    base = f"tg_{msg.chat.id}_{msg.message_id}_{ts}"

    if msg.document:
        return msg.document.file_name or (base + "_document")
    if msg.photo:
        return base + "_photo.jpg"
    if msg.video:
        return base + "_video.mp4"
    if msg.audio:
        return msg.audio.file_name or (base + "_audio")
    if msg.voice:
        return base + "_voice.ogg"
    if msg.sticker:
        return base + "_sticker.webp"
    if msg.text:
        return base + "_text.txt"
    return base + "_file"


async def upload_to_drive(group_id: int, group_title: str, msg: types.Message) -> Optional[str]:
    creds = ensure_valid_creds(group_id)
    if not creds:
        return None

    drive = build_drive(creds)
    folder_id = get_or_create_group_folder(group_id, group_title, drive)

    # Prepare local file
    filename = guess_filename_from_message(msg)
    local_path = os.path.join(TMP_DIR, filename)

    mime_type = None

    if msg.text and not (msg.document or msg.photo or msg.video or msg.audio or msg.voice or msg.sticker):
        with open(local_path, "w", encoding="utf-8") as f:
            f.write(msg.text)
        mime_type = "text/plain"

    elif msg.document:
        await download_telegram_file(msg.document.file_id, local_path)
        mime_type = msg.document.mime_type

    elif msg.photo:
        # take biggest
        photo = msg.photo[-1]
        await download_telegram_file(photo.file_id, local_path)
        mime_type = "image/jpeg"

    elif msg.video:
        await download_telegram_file(msg.video.file_id, local_path)
        mime_type = msg.video.mime_type or "video/mp4"

    elif msg.audio:
        await download_telegram_file(msg.audio.file_id, local_path)
        mime_type = msg.audio.mime_type

    elif msg.voice:
        await download_telegram_file(msg.voice.file_id, local_path)
        mime_type = "audio/ogg"

    elif msg.sticker:
        await download_telegram_file(msg.sticker.file_id, local_path)
        mime_type = "image/webp"

    else:
        return None

    body = {"name": filename, "parents": [folder_id]}
    media = MediaFileUpload(local_path, mimetype=mime_type, resumable=False)
    created = drive.files().create(body=body, media_body=media, fields="id").execute()

    # cleanup
    try:
        os.remove(local_path)
    except Exception:
        pass

    return created.get("id")


# =========================
# Handlers
# =========================
@dp.message_handler(commands=["start"])
async def cmd_start(message: types.Message):
    if not is_private(message):
        return

    # deep link parameter: /start setup_<groupid>
    parts = (message.get_args() or "").strip()
    if parts.startswith("setup_"):
        try:
            group_id = int(parts.split("_", 1)[1])
            pending_setup[message.from_user.id] = group_id
            groups = get_groups()
            group_meta = groups.get(str(group_id), {})
            title = group_meta.get("title") or str(group_id)

            if not os.path.exists(client_secret_path()):
                await message.answer(SETUP_NEED_CLIENT_SECRET, reply_markup=kb_private_home())
                return

            auth_url = build_oauth_url()
            await message.answer(
                f"âœ… Ø§Ø®ØªØ±Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: <b>{title}</b>\n\n"
                f"1) Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù‡Ø°Ø§ ÙˆØ³Ø¬Ù‘Ù„ Ø¯Ø®ÙˆÙ„Ùƒ ÙˆÙˆØ§ÙÙ‚:\n{auth_url}\n\n"
                "2) Google Ø¨ÙŠØ¹Ø·ÙŠÙƒ <b>code</b>\n"
                "3) Ø§Ù„ØµÙ‚ <b>Ø§Ù„ÙƒÙˆØ¯ Ù‡Ù†Ø§</b> ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø£ÙˆØ§Ù…Ø±)\n",
                reply_markup=kb_setup_actions(group_id),
                disable_web_page_preview=True,
            )
            return
        except Exception:
            # fall through to normal welcome
            pass

    await message.answer(WELCOME_TEXT, reply_markup=kb_private_home())


@dp.callback_query_handler(lambda c: c.data == "home")
async def cb_home(call: types.CallbackQuery):
    await call.message.edit_text(WELCOME_TEXT, reply_markup=kb_private_home(), disable_web_page_preview=True)
    await call.answer()


@dp.callback_query_handler(lambda c: c.data == "info")
async def cb_info(call: types.CallbackQuery):
    await call.message.edit_text(INFO_TEXT, reply_markup=kb_private_home(), disable_web_page_preview=True)
    await call.answer()


@dp.callback_query_handler(lambda c: c.data == "help")
async def cb_help(call: types.CallbackQuery):
    await call.message.edit_text(HELP_TEXT, reply_markup=kb_private_home(), disable_web_page_preview=True)
    await call.answer()


@dp.callback_query_handler(lambda c: c.data == "setup")
async def cb_setup(call: types.CallbackQuery):
    if not os.path.exists(client_secret_path()):
        await call.message.edit_text(SETUP_NEED_CLIENT_SECRET, reply_markup=kb_private_home())
        await call.answer()
        return

    groups = get_groups()
    if not groups:
        await call.message.edit_text(
            "Ù…Ø§ Ù„Ù‚ÙŠØª Ø£ÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ø¶Ø§Ù ÙÙŠÙ‡Ø§ Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ø­ÙŠÙ†.\n\n"
            "âœ… Ø£ÙˆÙ„ Ø´ÙŠØ¡: Ø£Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ù„Ù…Ø¬Ù…ÙˆØ¹ØªÙƒØŒ ÙˆØ¨Ø¹Ø¯Ù‡Ø§ Ø§Ø±Ø¬Ø¹ Ù‡Ù†Ø§ ÙˆØ§Ø¶ØºØ· Setup.",
            reply_markup=kb_private_home(),
        )
        await call.answer()
        return

    await call.message.edit_text(SETUP_INTRO, reply_markup=kb_groups_list(groups))
    await call.answer()


@dp.callback_query_handler(lambda c: c.data.startswith("pick_group:"))
async def cb_pick_group(call: types.CallbackQuery):
    if not is_private(call.message):
        await call.answer()
        return

    if not os.path.exists(client_secret_path()):
        await call.message.edit_text(SETUP_NEED_CLIENT_SECRET, reply_markup=kb_private_home())
        await call.answer()
        return

    group_id = int(call.data.split(":", 1)[1])
    pending_setup[call.from_user.id] = group_id

    groups = get_groups()
    title = groups.get(str(group_id), {}).get("title") or str(group_id)

    auth_url = build_oauth_url()
    await call.message.edit_text(
        f"âœ… Ø§Ø®ØªØ±Øª Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: <b>{title}</b>\n\n"
        f"1) Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù‡Ø°Ø§ ÙˆØ³Ø¬Ù‘Ù„ Ø¯Ø®ÙˆÙ„Ùƒ ÙˆÙˆØ§ÙÙ‚:\n{auth_url}\n\n"
        "2) Google Ø¨ÙŠØ¹Ø·ÙŠÙƒ <b>code</b>\n"
        "3) Ø§Ù„ØµÙ‚ <b>Ø§Ù„ÙƒÙˆØ¯ Ù‡Ù†Ø§</b> ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© (Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø£ÙˆØ§Ù…Ø±)\n",
        reply_markup=kb_setup_actions(group_id),
        disable_web_page_preview=True,
    )
    await call.answer()


@dp.message_handler(lambda m: is_private(m) and m.text and len(m.text.strip()) > 10)
async def handle_private_text(message: types.Message):
    """
    Use this to receive the OAuth code after setup selection.
    """
    user_id = message.from_user.id
    if user_id not in pending_setup:
        return

    code = message.text.strip()
    group_id = pending_setup[user_id]

    # Basic validation (avoid accidental words)
    if "http" in code.lower():
        await message.answer("Ø§Ù„Ù„ÙŠ Ø§Ø­ØªØ§Ø¬Ù‡ Ù‡Ùˆ <b>Ø§Ù„ÙƒÙˆØ¯</b> ÙÙ‚Ø· (Ù…Ùˆ Ø§Ù„Ø±Ø§Ø¨Ø·). Ø§Ù„ØµÙ‚Ù‡ Ù‡Ù†Ø§.", reply_markup=kb_private_home())
        return

    try:
        creds = exchange_code_for_creds(code)
        save_creds(group_id, creds)

        # Create folder early to confirm permissions
        groups = get_groups()
        title = groups.get(str(group_id), {}).get("title") or str(group_id)

        drive = build_drive(creds)
        folder_id = get_or_create_group_folder(group_id, title, drive)

        pending_setup.pop(user_id, None)
        await message.answer(
            "âœ… ØªÙ… Ø±Ø¨Ø· Google Drive Ø¨Ù†Ø¬Ø§Ø­!\n\n"
            f"â€¢ ØªÙ… ØªØ¬Ù‡ÙŠØ² Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© (ID): <code>{folder_id}</code>\n\n"
            "Ø§Ù„Ø¢Ù† Ø§Ø±Ø¬Ø¹ Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©:\n"
            "â€¢ Ø±Ø¯ Ø¹Ù„Ù‰ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© ÙˆØ§ÙƒØªØ¨: <code>archive</code>\n",
            reply_markup=kb_private_home(),
        )
    except Exception as e:
        log.exception("Setup failed")
        await message.answer(
            "âŒ Ù…Ø§ Ø¶Ø¨Ø· Ù…Ø¹ÙŠ Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„ÙƒÙˆØ¯ Ù‡Ø°Ø§.\n"
            "Ø¬Ø±Ù‘Ø¨ ØªØ·Ù„Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ© ÙˆØªÙ„ØµÙ‚Ù‡ Ù‡Ù†Ø§.\n\n"
            f"<code>{type(e).__name__}</code>",
            reply_markup=kb_private_home(),
        )


@dp.my_chat_member_handler()
async def on_my_chat_member(update: types.ChatMemberUpdated):
    """
    When bot is added to a group/supergroup, save group id+title
    and send a private hint to the user who added the bot (if possible).
    """
    try:
        chat = update.chat
        if chat.type not in (types.ChatType.GROUP, types.ChatType.SUPERGROUP):
            return

        # detect bot added/updated to member
        new_status = update.new_chat_member.status
        if new_status not in ("member", "administrator"):
            return

        groups = get_groups()
        groups[str(chat.id)] = {
            "title": chat.title or str(chat.id),
            "added_at": datetime.now(timezone.utc).isoformat(),
        }
        set_groups(groups)

        # try message the inviter
        inviter = update.from_user
        if inviter:
            deep_link = f"https://t.me/{(await bot.get_me()).username}?start=setup_{chat.id}"
            await safe_send_private(
                inviter.id,
                "âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©!\n\n"
                "Ø¹Ø´Ø§Ù† ØªØ±Ø¨Ø· Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ù€ Google Drive:\n"
                f"Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù‡Ø°Ø§ Ù…Ù† Ø§Ù„Ø®Ø§Øµ:\n{deep_link}\n\n"
                "Ø£Ùˆ Ø§ÙØªØ­ Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ø¶ØºØ·: Google Drive (Setup) ğŸ”—",
                reply_markup=kb_private_home(),
            )
    except Exception:
        pass


@dp.message_handler(lambda m: is_group(m) and m.reply_to_message and m.text)
async def handle_group_archive_keyword(message: types.Message):
    """
    Archive command in group: reply + "archive"
    """
    txt = (message.text or "").strip().lower()

    # only accept exact keyword to avoid noise
    if txt not in ("archive", "Ø£Ø±Ø´Ù", "Ø§Ø±Ø´ÙØ©", "Ø£Ø±Ø´ÙØ©"):
        return

    group_id = message.chat.id
    group_title = message.chat.title or str(group_id)

    # ensure setup exists
    creds = ensure_valid_creds(group_id)
    if not creds:
        # tell the user privately how to set up
        deep_link = f"https://t.me/{(await bot.get_me()).username}?start=setup_{group_id}"
        await message.reply("âš ï¸ Ù„Ø§Ø²Ù… Ø±Ø¨Ø· Google Drive Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£ÙˆÙ„Ù‹Ø§. (ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø±Ø¨Ø· ÙÙŠ Ø§Ù„Ø®Ø§Øµ Ù„Ù„Ø£Ø¯Ù…Ù†)")
        # send to the command sender
        await safe_send_private(
            message.from_user.id,
            f"ğŸ”— Ø¥Ø¹Ø¯Ø§Ø¯ Google Drive Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©: <b>{group_title}</b>\n"
            f"Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù‡Ø°Ø§:\n{deep_link}\n",
            reply_markup=kb_private_home(),
        )
        return

    status = await message.reply("â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø£Ø±Ø´ÙØ©...")
    try:
        file_id = await upload_to_drive(group_id, group_title, message.reply_to_message)
        if not file_id:
            await status.edit_text("âŒ Ù…Ø§ Ù‚Ø¯Ø±Øª Ø£Ø±ÙØ¹ Ù‡Ø°Ø§ Ø§Ù„Ù†ÙˆØ¹ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø©.")
            return
        await status.edit_text("âœ… ØªÙ…Øª Ø§Ù„Ø£Ø±Ø´ÙØ©.")
    except Exception as e:
        log.exception("archive failed")
        await status.edit_text(f"âŒ ÙØ´Ù„ Ø§Ù„Ø£Ø±Ø´ÙØ©: <code>{type(e).__name__}</code>")


@dp.errors_handler()
async def on_error(update, error):
    if isinstance(error, NetworkError):
        return True
    return False


# =========================
# MAIN
# =========================
async def on_startup(_):
    await configure_commands()
    log.info("Bot started")


if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True, on_startup=on_startup)
